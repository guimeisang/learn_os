### 局部页面置换算法
1. 最优算法
> 通过预测来决定
不足：操作系统很难知道接下是使用哪个页面，哪个功能
用处：可以做为已经发生的场景，采用该算法

2. 先进先出算法
> 基本思路：内存中驻留时间越长，先淘汰之
不足：可能会导致一些经常被访问会经常被替换出去，到硬盘中

3. 最近最久未使用算法
> 如果你的程序很长时间不被访问，那么将来被访问的概率也会很低
LRU 算法需要记录各个页面的使用时间的先后顺序，开销比较大，两种可能的实现方式：

- 方法1：维护一个页面链表，最近刚刚使用过的页面做为首节点，最久未使用的页面做为尾结点。每次缺页中断发生时，淘汰链表末尾的页面
- 方法2：设置一个活动页面栈，当访问某页时，将此页号压入栈顶，然后考察是否有此页面相同的页号，如果需要淘汰则

最少的时间来实现最好效果

4. 时钟页面置换算法
就像指针一样，并且做一个标记，算是听懂了，但是还是不知道效果咋样？？？
优点：只消耗一个bity

5. 二次机会发
写过的页，会增加一个dirty值，这样就会保证写的页会比读的页多一次机会

6. 最不常用发
当一个缺页中断发生时，选择访问次数最少的那个页面，并且淘汰之
还需要一个链表来存访问次数

总结：
1. Belady现象：采用FIFO算法，出现分配的物理页面数增多，缺页率反而提高的异常现象


### 全局页面置换算法
1， 工作集
> 最怕那种动态的调整